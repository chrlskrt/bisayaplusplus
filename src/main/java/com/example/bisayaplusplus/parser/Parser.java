/* PARSER
 * This class is responsible for parsing the tokens generated by the lexer,
 * and converting them into an Abstract Syntax Tree (AST).
 *
 * The parser interprets the statements, variables, expressions, and
 * control flow structures defined in the Bisaya++ language.
 *
 * This will check for syntax errors and report them back to the user.
 */

package com.example.bisayaplusplus.parser;

import com.example.bisayaplusplus.exception.ParserException;
import com.example.bisayaplusplus.lexer.Lexer;
import com.example.bisayaplusplus.lexer.Token;
import com.example.bisayaplusplus.lexer.TokenType;
import java.util.ArrayList;
import java.util.List;

public class Parser {
    private final List<Token> tokens;
    private int current = 0;
    private final AstPrinter astPrinter = new AstPrinter();

    public Parser(List<Token> tokens){
        this.tokens = tokens;
    }

    /*
     * Main function that does the parsing
     * Returns a list of statements that will serve as input for the interpreter.
     *
     * Checks the grammar for the whole program.
     */
    public List<Stmt> parse() throws ParserException {
        List<Stmt> statements = new ArrayList<>();

        if (tokens.isEmpty()){
            return statements;
        }

        // START STATEMENT
        if (!matchToken(TokenType.START_STMT)){
            throw new ParserException("Expected 'SUGOD' at the start of the program.", getCurrToken().getLine());
        }

        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", "'SUGOD' statement.", true);

        String typeStmt;
        // go through all the tokens after SUGOD
        while (!matchToken(TokenType.END_STMT) && !isAtEnd()){
            typeStmt = parseStatements(statements); // parse individual statement

            // for NEW_LINE after every statement
            if (!typeStmt.equals("IF") && !typeStmt.equals("FOR LOOP")){
                expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", typeStmt + " statement. 1 statement per line.", true);
            }
        }

        if (isAtEnd() && getPrevToken().getTokenType() != TokenType.END_STMT){
            throw new ParserException("Expected 'KATAPUSAN' at the end of the program.", getPrevToken().getLine() + 1);
        }

        System.out.println("Is at end of the program? " + isAtEnd());

        // checking if there's extra code after a 'KATAPUSAN' that is not a new_line character
        if (!isAtEnd()){
            while (isCurrTokenType(TokenType.NEW_LINE)){
                advance();
            }

            if (!isAtEnd()){
                throw new ParserException("Unexpected '" + getCurrToken().getLiteral() + "' - " + getCurrToken().getTokenType() + " found after 'KATAPUSAN' end statement.", getCurrToken().getLine());
            }
        }

        return statements;
    }

    /* Function that will check for individual statement per line.
     * @param statements - list of existing statements, where we add the new statement.
     *
     * Returns a string that contains the type of statement na na-parse
     */
    private String parseStatements(List<Stmt> statements) throws ParserException {
        // Comment
        if (matchToken(TokenType.COMMENT)){
            return "COMMENT";
        }

        // Variable declarations
        if (matchToken(TokenType.CREATE_STMT)) {
            statements.addAll(parseVarDeclaration(false));
            return "CREATE";
        }

        // Print statement
        if (matchToken(TokenType.PRINT_STMT)){
            statements.add(parsePrintStatement());
            return "PRINT";
        }

        // If statement
        if (matchToken(TokenType.IF)) {
            statements.add(parseIfStmt());
            return "IF";
        }

        // While loop
        if (matchToken(TokenType.WHILE_LOOP)){
            statements.add(parseWhileLoopStmt());
            return "WHILE LOOP";
        }

        // For-loop
        if (matchToken(TokenType.FOR_LOOP)){
            statements.add(parseForLoopStmt());
            return "FOR LOOP";
        }

        // Expr statements
        Stmt exprStmt = parseExprStatement();
        statements.add(exprStmt);
        return ((Stmt.Expression) exprStmt).expression.getClass().getSimpleName();
    }

    // variable declaration
    // returns a list of statements that contains 1 or more variable declarations
    private List<Stmt> parseVarDeclaration(boolean isForLoopInit) throws ParserException {
        String dataType = switch (getCurrToken().getTokenType()) {
            case INT_KEYWORD -> "integer";
            case BOOL_KEYWORD -> "boolean";
            case CHAR_KEYWORD -> "character";
            case DOUBLE_KEYWORD -> "double";
            default ->
                    throw new ParserException("Expected DATA_TYPE after 'MUGNA', but received " + getCurrToken().getTokenType() + " \"" + getCurrToken().getLiteral() + "\"", getCurrToken().getLine());
        };

        advance(); // consume data type

        List<Stmt> varDeclarations = new ArrayList<>();

//        int tempCurr; // for traversal purposes during for-loop declaration
        do {
//            tempCurr = current;
            Token name = expectAndConsumeToken(TokenType.IDENTIFIER, "IDENTIFIER", "DATA_TYPE / COMMA.", false);
            Expr initializer = null;
            if (matchToken(TokenType.EQUAL)){
                System.out.println(name.getLiteral() + " has initialized value");
                initializer = parseExpression();
                System.out.println(name.getLiteral() + " is initialized with " + astPrinter.print(initializer));
            }
//            else if (isForLoopInit){
////                current = tempCurr - 1;
////                break;
//            }

            varDeclarations.add(new Stmt.Var(dataType, name, initializer));
        } while (!isForLoopInit && matchToken(TokenType.COMMA));

        return varDeclarations;
    }

    //---------- Parsing WHILE LOOP --------------------
    /* Syntax:
     *
     * MINTRAS (condition)
     * PUNDOK {
     *      -- statement*
     * }
     *
     */
    private Stmt parseWhileLoopStmt() throws ParserException {
        expectAndConsumeToken(TokenType.LEFT_PAREN, "(", " WHILE LOOP.", false);
        Expr condition = parseExpression();
        expectAndConsumeToken(TokenType.RIGHT_PAREN, ")", " condition for WHILE LOOP.", false);

        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " WHILE LOOP declaration", false);

        Stmt body = new Stmt.Block(parseBlock("WHILE_LOOP"));

        return new Stmt.While(condition, body);
    }

    //---------- Parsing FOR LOOP ---------------------
    private Stmt parseForLoopStmt() throws ParserException {
        expectAndConsumeToken(TokenType.LEFT_PAREN, "("," ALANG SA.", false);

        // getting initialization statement
//        // multiple initialization statements
//        List<Stmt> initialization = new ArrayList<>();
//        if (matchToken(TokenType.CREATE_STMT)){
//            initialization.addAll(parseVarDeclaration(true));
//        } else {
//            initialization.add(parseExprStatement());
//        }
        Stmt initialization;
        if (matchToken(TokenType.CREATE_STMT)){
            initialization = (parseVarDeclaration(true)).get(0);
        } else {
            initialization = parseExprStatement();
        }

        expectAndConsumeToken(TokenType.COMMA, ",", " initialization statement in FOR LOOP.", false);

        // parsing condition
        Expr condition = parseExpression();
        expectAndConsumeToken(TokenType.COMMA, ",", astPrinter.print(condition) + " condition expression in FOR LOOP.", false);

        Stmt update = parseExprStatement();

        expectAndConsumeToken(TokenType.RIGHT_PAREN, ")", astPrinter.print(((Stmt.Expression) update).expression) + " update expression in FOR LOOP", false);
        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " FOR_LOOP declaration.", false);
        Stmt forBody = new Stmt.Block(parseBlock("FOR-LOOP"));

        return new Stmt.ForLoop(initialization, condition, update, forBody);
    }

    //---------- Parsing IF statements ------------------
    private Stmt parseIfStmt() throws ParserException {
        expectAndConsumeToken(TokenType.LEFT_PAREN, "(", "IF keyword.", false);
        Expr condition = parseExpression();
        expectAndConsumeToken(TokenType.RIGHT_PAREN, ")", "the IF condition.", false);
        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", "the IF statement. To parse PUNDOK for IF.", false);

        // for if block statements
        Stmt thenBranch = new Stmt.Block(parseBlock("IF BLOCK"));
        List<Stmt.ElseIf> elseIfBranch = null;
        Stmt elseBranch = null;

        if (matchToken(TokenType.IF_ELSE)){
            elseIfBranch = new ArrayList<>();
            do {
                // getting condition
                expectAndConsumeToken(TokenType.LEFT_PAREN, "(", " ELSE_IF keyword.", false);
                Expr elIfCondition = parseExpression();
                expectAndConsumeToken(TokenType.RIGHT_PAREN, ")", " the ELSE_IF condition.", false);
                expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " the ELSE_IF statement. Only 1 statement per line.", false);

                // storing and getting executable statements under el-if block
                elseIfBranch.add(new Stmt.ElseIf(elIfCondition, new Stmt.Block(parseBlock("ELSE-IF-"+(elseIfBranch.size() + 1)))));
            } while (matchToken(TokenType.IF_ELSE));
        }

        if (matchToken(TokenType.ELSE)){
            expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " ELSE statement. Only 1 statement per line.", false);
            elseBranch = new Stmt.Block(parseBlock("ELSE BLOCK"));
        }

        if (matchToken(TokenType.ELSE)) throw new ParserException("You can only have 1 else block per if-else statements.", getPrevToken().getLine());

        return new Stmt.If(condition, thenBranch, elseIfBranch, elseBranch);
    }

    /* A function that will check if the condition provided for the IF statement
     * is a boolean/logical expression.
     *
     * Directly throws an error if the condition is not valid.
     */
    private void checkIfBooleanExpr(Expr condition, String stmt) throws ParserException {
        if (!(condition instanceof Expr.Logical)){
            Expr expr = condition;
            while (expr instanceof Expr.Grouping){
                expr = ((Expr.Grouping) expr).expression;
            }

            if (!(expr instanceof Expr.Logical)){
                if (expr instanceof Expr.Assign){
                    throw new ParserException("Invalid " + stmt + " condition. Maybe you meant \"==\" instead of \"=\"?", getPrevToken().getLine());
                }

                throw new ParserException("Invalid " + stmt + " condition. Expected BOOLEAN expression.", getPrevToken().getLine());
            }
        }
    }

    /*
     * PRINT STATEMENT SYNTAX
     * IPAKITA: {EXPR} (& {EXPR})*
     */
    private Stmt parsePrintStatement() throws ParserException {
        expectAndConsumeToken(TokenType.COLON, ":", " IPAKITA statement.", false);
        Expr value = parseExpression();
        System.out.println("the value for print: " + astPrinter.print(value));
        return new Stmt.Print(value);
    }

    // for code blocks - code sulod sa PUNDOK {}
    private List<Stmt> parseBlock(String blockName) throws ParserException {
        expectAndConsumeToken(TokenType.CODE_BLOCK, "PUNDOK", blockName + " statement.", false);
        List<Stmt> blockStatements = new ArrayList<>();
        expectAndConsumeToken(TokenType.LEFT_CURLY, "{", " PUNDOK statement. Code block: " + blockName, false);
        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " '{' in PUNDOK statement.", false);

        String typeStmt;
        while (!isCurrTokenType(TokenType.RIGHT_CURLY) && !isAtEnd()){
            typeStmt = parseStatements(blockStatements);

            // for NEW_LINE after every statement
            if (!typeStmt.equals("IF") && !typeStmt.equals("FOR LOOP")){
                expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", typeStmt + " statement inside PUNDOK", false);
            }
        }

        expectAndConsumeToken(TokenType.RIGHT_CURLY, "}", " block. Code block: " + blockName, false);
        expectAndConsumeToken(TokenType.NEW_LINE, "NEW_LINE", " PUNDOK for " + blockName + " block.", true);
        return blockStatements;
    }

    // PARSING EXPRESSION STATEMENTS - refers mostly to mathematical expressions
    // Valid expression statements -> Assignment (e.g. x = 2, x += 2) and Increment/Decrement (e.g. x++, --x)
    private Stmt parseExprStatement() throws ParserException {
        Expr expr = parseAssignment();
        if (!(expr instanceof Expr.Assign) && !(expr instanceof Expr.IncrementOrDecrement)){
            throw new ParserException("Invalid statement. " + astPrinter.print(expr), getPrevToken().getLine());
        }
        return new Stmt.Expression(expr);
    }

    // Mathematical expressions
    private Expr parseExpression() throws ParserException {
        return parseAssignment();
    }

    // check assigning variable value
    private Expr parseAssignment() throws ParserException {
        Expr expr = parseLogicalOR();

        if (matchToken(TokenType.EQUAL)){
            System.out.println("Assignment");
            Token equals = getPrevToken();
            Expr value = parseAssignment();

            if (expr instanceof Expr.Variable){
                Token name = ((Expr.Variable) expr).name;
                System.out.println(name);
                astPrinter.print(value);
                return new Expr.Assign(name, value);
            }

            if (expr instanceof Expr.Literal){
                throw new ParserException("Invalid assignment target. Cannot assign to a Literal. Maybe you meant '=='?", getPrevToken().getLine());
            }

            throw new ParserException("Invalid assignment target.", equals.getLine());
        }


        return expr;
    }

    private Expr parseLogicalOR() throws ParserException {
        Expr expr = parseLogicalAND();

        while (matchToken(TokenType.LOGIC_OR)){
            Token operator = getPrevToken();
            Expr right = parseLogicalAND();
            expr = new Expr.Logical(expr, operator, right);
        }

        return expr;
    }

    private Expr parseLogicalAND() throws ParserException {
        Expr expr = parseEquality();

        while (matchToken(TokenType.LOGIC_AND)){
            Token operator = getPrevToken();
            Expr right = parseEquality();
            expr = new Expr.Logical(expr, operator, right);
        }

        return expr;
    }

    private Expr parseEquality() throws ParserException {
        Expr expr = parseComparison();

        while (matchToken(TokenType.NOT_EQUAL, TokenType.DOUBLE_EQUAL)) {
            Token operator = getPrevToken();
            Expr right = parseComparison();
            expr = new Expr.Logical(expr, operator, right);
        }

        return expr;
    }

    private Expr parseComparison() throws ParserException {
        Expr expr = parseTerm();

        while (matchToken(TokenType.GREATER_THAN, TokenType.GREATER_OR_EQUAL, TokenType.LESSER_THAN, TokenType.LESSER_OR_EQUAL)) {
            Token operator = getPrevToken();
            Expr right = parseTerm();
            expr = new Expr.Logical(expr, operator, right);
        }

        return expr;
    }

    private Expr parseTerm() throws ParserException {
        Expr expr = parseFactor();

        while (matchToken(TokenType.MINUS, TokenType.PLUS, TokenType.CONCAT)) {
            Token operator = getPrevToken();
            Expr right = parseFactor();
            expr = new Expr.Binary(expr, operator, right);
        }

        return expr;
    }

    private Expr parseFactor() throws ParserException {
        Expr expr = parseUnary();

        while (matchToken(TokenType.DIVIDE, TokenType.MULTIPLY, TokenType.MODULO)) {
            Token operator = getPrevToken();
            Expr right = parseUnary();
            expr = new Expr.Binary(expr, operator, right);
        }

        return expr;
    }

    private Expr parseUnary() throws ParserException {
        if (matchToken(TokenType.LOGIC_NOT, TokenType.NEGATIVE, TokenType.POSITIVE)) {
            Token operator = getPrevToken();
            Expr right = parseUnary();

            if (operator.getTokenType() == TokenType.LOGIC_NOT){
                return new Expr.Logical(null, operator, right);
            }

            return new Expr.Unary(operator, right);
        }

        if (matchToken(TokenType.INCREMENT, TokenType.DECREMENT)){
            Token operator = getPrevToken();
            Expr var = parsePrimary();

            if (!(var instanceof Expr.Variable)){
                throw new ParserException("Operand for " + operator.getTokenType() + " must be a variable.", getPrevToken().getLine());
            }

            return new Expr.IncrementOrDecrement(operator, (Expr.Variable) var, true);
        }

        return parsePrimary();
    }

    private Expr parsePrimary() throws ParserException {
        if (isAtEnd()){
            throw new ParserException("Unexpected EOF while parsing. Expected expression not found.", getPrevToken().getLine());
        }

        System.out.println("parsePrimary: " + getCurrToken().getLiteral() + getCurrToken().getTokenType());
        if (matchToken(TokenType.BOOL_FALSE, TokenType.BOOL_TRUE)) return new Expr.Literal("boolean", getPrevToken().getLiteral());
        if (matchToken(TokenType.NULL)) return new Expr.Literal("null", null);
        if (matchToken(TokenType.CHARACTER)) return new Expr.Literal("character", getPrevToken().getLiteral());
        if (matchToken(TokenType.INTEGER)) return new Expr.Literal("integer", getPrevToken().getLiteral());
        if (matchToken(TokenType.DOUBLE)) return new Expr.Literal("double", getPrevToken().getLiteral());
        if (matchToken(TokenType.STRING)) return new Expr.Literal("string", getPrevToken().getLiteral());
        if (matchToken(TokenType.ESCAPE_CHAR)) {
            char esc = (char) getPrevToken().getLiteral();
            return switch (esc) {
                case 'r' -> new Expr.Literal("character", '\r');
                case 'n' -> new Expr.Literal("character", '\n');
                case 't' -> new Expr.Literal("character", '\t');
                default -> new Expr.Literal("character", getPrevToken().getLiteral());
            };
        }
        if (matchToken(TokenType.IDENTIFIER)) {
            Expr.Variable var = new Expr.Variable(getPrevToken());
            if (matchToken(TokenType.INCREMENT, TokenType.DECREMENT)){
                return new Expr.IncrementOrDecrement(getPrevToken(), var, false);
            }

            return var;
        }
        if (matchToken(TokenType.LEFT_PAREN)){
            Expr expr = parseExpression();
            expectAndConsumeToken(TokenType.RIGHT_PAREN, ")", " expression.", false);
            System.out.println("return grouping");
            return new Expr.Grouping(expr);
        }
        if (matchToken(TokenType.CNEW_LINE)) return new Expr.Literal("character", '\n');
//        if (matchToken(TokenType.NEW_LINE)) throw new ParserException("Expected new statement in line. Every line should contain 1 statement.", getPrevToken().getLine());

        if (matchToken(TokenType.IF_ELSE, TokenType.ELSE)){
            throw new ParserException("Invalid syntax for IF statement. Missing IF code block.", getPrevToken().getLine());
        }

        Token token = getCurrToken();
        throw new ParserException("Unexpected token '" +   ((token.getLiteral() == null ? token.getTokenType().toString() : token.getLiteral())) + "' found. Expected an expression.", token.getLine());
    }

    // error recovery function in the parser
    private void synchronize() {
        advance();

        // Skip tokens until a valid statement start is found
        while (!isAtEnd()){
            if (getPrevToken().getTokenType() == TokenType.NEW_LINE) return; // stops at a NEW_LINE
            if (Lexer.keywords.containsValue(getCurrToken().getTokenType())){
                return; // stops at a keyword
            }

            advance(); // skip invalid tokens
        }
    }

    // function for throwing errors
    private Token expectAndConsumeToken(TokenType expectedType, String expToken, String afterWhat, boolean isEndOfStmt) throws ParserException {
        if (isAtEnd() && !isEndOfStmt) {
            throw new ParserException("Unexpected EOF while parsing. Expect '"+expToken+"' after " + afterWhat, getPrevToken().getLine());
        } else if (isAtEnd() && isEndOfStmt && expectedType == TokenType.NEW_LINE){
            throw new ParserException("Expect 'KATAPUSAN' at end of program.", getPrevToken().getLine() + 1);
        } else if (isEndOfStmt && (expectedType == TokenType.NEW_LINE) && isCurrTokenType(TokenType.END_STMT)){
            System.out.println("endende");
            current--;
            return advance();
        }

        if (isCurrTokenType(TokenType.COMMENT)){
            advance();
        }

        if (isCurrTokenType(expectedType)) return advance(); // if the token type matches, it will increment current counter

        // if the type does not match
        Token token = getCurrToken();

        // throws exception. it gives the message and the token that was found instead of the expected tokentype
        throw new ParserException("Expect '"+ expToken + "' after " + afterWhat + " Received: " + ((token.getLiteral()) == null ? token.getTokenType().toString() : token.getLiteral()), token.getLine());
    }

    // checks if the current expr has any of those token types
    // automatically advances to the next token type if found a match
    // accepts one or many tokentypes to check
    private boolean matchToken(TokenType... types) {
        for (TokenType type : types) {
            if (isCurrTokenType(type)) {
                advance();
                return true;
            }
        }

        return false;
    }

    // checks if the current token type is the same as the given type
    private boolean isCurrTokenType(TokenType type){
        if (isAtEnd()) return false;
        return getCurrToken().getTokenType() == type;
    }

    // get next token, increment current counter
    private Token advance() {
        if (!isAtEnd()) current++;
        return getPrevToken();
    }

    // get next token wo incrementing the current counter
    private Token getCurrToken() {

        return tokens.get(current);
    }

    // get previous token
    private Token getPrevToken() {
        return tokens.get(current - 1);
    }

    // check if the parser has already reached the end of the program
    private boolean isAtEnd(){
        return current >= tokens.size();
    }
}
